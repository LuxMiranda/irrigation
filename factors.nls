;;;;;;;;;;;;;;;;;;;;;;;;;; Internal functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Probabilize a basic value
to-report probabilize [o x]
  report -1 * (abs ((o - x) / probabilization-obtuseness)) + 1
end


;; A standard normal probability density function
;; Mu - mean (expected)
;; Sd - standard deviation
to-report normal-probability-density [ mu sd x ]
  let coeff 1 / (sd * (sqrt (2 * pi)))
  let power -0.5 * (((x - mu) / sd) ^ 2)
  report coeff * (exp power)
end
 
;; Truncate an investment if it exceeds possible investment boundaries
to-report truncate [ investment ]
  if investment < 0 [ report 0 ]
  if investment > 10 [ report 10 ]
  report investment
end

;; Retrieve the index of the largest item in a list
to-report max-index [xs] 
  ;; Indices
  let maxIndex 0
  let i 0
  ;; Fetch the first element
  let maxElem (item 0 xs)
  ;; For each item in the list
  foreach xs [ [x] ->
    ;; If the current item is larger than the last seen maxElem, set a new maxElem & maxIndex
    if (x > maxElem) [
      set maxElem x
      set maxIndex i
    ]
    set i (i + 1)
  ]
  report maxIndex
end

;; Retrieve the index of the smallest item in a list
to-report min-index [xs]
  ;; Indices
  let minIndex 0
  let i 0
  ;; Fetch the first element
  let minElem (item 0 xs)
  ;; For each item in the list
  foreach xs [ [x] ->
    ;; If the current item is smaller than the last seen minElem, set a new minElem & minIndex
    if (x < minElem) [
      set minElem x
      set minIndex i
    ]
    set i (i + 1)
  ]
  report minIndex
end

;;;;;;;;;;;;;;;;;;;;;;;;;; Operators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; takes two subscore reporters and concats them with an addition operator
;; @EMD @Factor @return-type=comparator @parameter-type=comparator @parameter-type=comparator
to-report combine [a b]
  report (word "(" a " + " b ")")
end
;; takes two subscore reporters and concats them with an addition operator
;; @EMD @Factor @return-type=comparator @parameter-type=comparator @parameter-type=comparator
to-report subtract [a b]
  report (word "(" a " - " b ")")
end

;; takes two subscore reporters and concats them with a division operator
;; @EMD @Factor @return-type=comparator @parameter-type=comparator @parameter-type=comparator
to-report divide [a b]
  report (word "(" a " / (0.0000000001 + " b "))")
end

;; takes two subscore reporters and concats them with a multiplication operator
;; @EMD @Factor @return-type=comparator @parameter-type=comparator @parameter-type=comparator
to-report multiply [a b]
  report (word "(" a " * " b ")")
end

;;;;;;;;;;;;;;;;;;;;;;;;;;; Generators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Generator for possible-investments
;; @EMD @Factor @return-type=possible-investments
to-report possible-decisions 
  report [0 1 2 3 4 5 6 7 8 9 10]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;; Combiners ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; @EMD @Factor @return-type=investment-amount @parameter-type=possible-investments @parameter-type=comparator
to-report get-max-one-of [ possible-invests factor-function ]
  let _selection max-index (map (runresult (word "[[x] -> " factor-function "]")) possible-invests)
  report _selection
end

;; @EMD @Factor @return-type=investment-amount @parameter-type=possible-investments @parameter-type=comparator
to-report get-min-one-of [ possible-invests factor-function ]
  let _selection min-index (map (runresult (word "[[x] -> " factor-function "]")) possible-invests)
  report _selection
end

;;;;;;;;;;;;;;;;;;;;;;;;;; Factors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Probabilization of the "selfish" investment (0 tokens)
;; @EMD @Factor @return-type=comparator
to-report consider-selfishness
  report "(probabilize 0 x)"
end

;; Probabilization of the "altruistic" investment (10 tokens)
;; @EMD @Factor @return-type=comparator
to-report consider-altruism
  report "(probabilize 10 x)"
end

;; A random comparator 
;; @EMD @Factor @return-type=comparator
to-report consider-random
  ;; lol im so random rawr xD
  report "(random-float 1)"
end

;; Comparator with importance defined on a normal destribution with a pseudorandomly selected mean
;; @EMD @Factor @return-type=comparator
to-report consider-pseudorandom
  ;; At the zeroth tick, set the base investment
  if ticks = 0 [
    set baseinvest truncate (random-normal meaninv sdinv)
  ]
  ;; Return a normal probability density with mean=baseinvest and sd=sdnoise
  report "(normal-probability-density baseinvest sdnoise x)"
end

;; Comparator that simply probabilizes the heuristic model
;; @EMD @Factor @return-type=comparator
to-report consider-heuristic
  if ticks = 0 [
    set agt random-float 1
    ifelse agt <= pself [
      ;; Return a uniform random comparator if x <= 5, or 0 otherwise
      report "(ifelse-value (x <= 5) [ random-float 1 ] [ 0 ])"
    ]
    ;; Else agt > pself
    [
      ;; Return a uniform random comparator if x > 5, or 0 otherwise
      report "(ifelse-value (x > 5) [ random-float 1 ] [ 0 ])"
    ]
  ]
  report "(probabilize (truncate ((10 * trust) * (impact ^ roi))) x)"
end

;; Comparator considering the other-regarding preference model. This code is largly unchanged,
;; as the model is already formulated as a probability distribution! We simply report the 
;; distribution rather than picking from it. 
;; @EMD @Factor @return-type=comparator
to-report consider-utilitarian
  let i 0     
  set utiltot 0
  set utillist []
  ; Calculate the expected utility for each of the 11 possible investment levels
  while [i <= 10]
  [
    set invest (4 * 10 * expcoopothers) + i
    set pg calpg invest 
    ifelse ticks = 0 [
      let exponent (2 - expcoopothers)
      set pga pg * (1 - (who / 5) ^ exponent)
      ifelse pg > 0 [set expshare pga / pg][set expshare 0]
      if (1 - alpha) * (1 - beta) < 1 [set pga pga * (1 - alpha) * (1 - beta)]
    ][
      set pga pg * expshare
      if (1 - alpha) * (1 - beta) < 1 [set pga pga * (1 - alpha) * (1 - beta)]
    ]  
    set income 10 - i + pga
    set incomeothers (40 - (10 * 4 * expcoopothers) + (pg - pga)) / 4

    let dif1 0
    let dif2 0
    ifelse income > incomeothers [
      set dif1 income - incomeothers 
      set dif2 0
    ][
      set dif1 0 
      set dif2 incomeothers - income
    ]
    set utility exp (lambda * (income -  alpha * dif1 + beta * dif2)) 
    set utillist lput utility utillist
    set utiltot utiltot + utility
    set i i + 1
  ]  
  set i 0 
  set probinvest []
  while [i <= 10]
  [  
    ifelse utiltot > 0 [
      set probinvest lput (item i utillist / utiltot) probinvest
    ][
      set probinvest lput 0.2 probinvest
    ]   
    set i i + 1
  ] 
  ;; The one key insertion!
  report "(item x probinvest)"
end
